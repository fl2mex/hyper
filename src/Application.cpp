#include "Application.h"

namespace hyper
{
	static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
	{
		if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		{
			glfwSetWindowShouldClose(window, GLFW_TRUE);
		}
	}

	static std::vector<char> readFile(std::string filename)
	{
		std::ifstream file(filename, std::ios::ate | std::ios::binary);
		if (!file.is_open())
		{
			std::cerr << "Failed to load \"" << filename << "\" \nMake sure your shader's location or filepath are correct!" << std::endl;
			return {}; // Need to add error handling to the constructor
		}
		size_t filesize{ static_cast<size_t>(file.tellg()) }; // Get the size of the file by seeking to the end and getting the position
		std::vector<char> buffer(filesize);
		file.seekg(0); // Seek back to the beginning
		file.read(buffer.data(), filesize);
		file.close();
		return buffer;
	}

	static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType,
		const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) // Needed and autogenerated for validation layers
	{
		std::cerr << "validation layer: " << pCallbackData->pMessage << std::endl;
		return VK_FALSE;
	}

	Application::Application(Spec _spec)
		: m_Spec(_spec)
	{
		glfwInit();
		glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // GLFW wants GLFW_NO_API for vulkan
		m_Window = glfwCreateWindow(m_Spec.Width, m_Spec.Height, m_Spec.Title.c_str(), nullptr, nullptr);
		glfwSetKeyCallback(m_Window, key_callback);
		// Are the last two parameters meant to be the same as the second?
		vk::ApplicationInfo appInfo(m_Spec.Title.c_str(), m_Spec.ApiVersion, "hyper", m_Spec.ApiVersion, m_Spec.ApiVersion);

		uint32_t glfwExtensionCount = 0u;
		const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);
		std::vector<const char*> glfwExtensionsVector(glfwExtensions, glfwExtensions + glfwExtensionCount), layers;

		if (m_Spec.Debug)
		{
			glfwExtensionsVector.push_back("VK_EXT_debug_utils"); // Apparently turning these on has a performance hit
			layers.push_back("VK_LAYER_KHRONOS_validation");
		}

		log("Extensions available: "); for (auto& e : vk::enumerateInstanceExtensionProperties()) log(" - " << e.extensionName);
		log("Extensions used: "); for (int i = 0; i < glfwExtensionCount; i++) log(" - " << glfwExtensions[i]);
		log("Validation layers available: "); for (auto& l : vk::enumerateInstanceLayerProperties()) log(" - " << l.layerName);
		log("Validation layers used: "); for (auto& l : layers) log(" - " << l);

		m_Instance = vk::createInstanceUnique(vk::InstanceCreateInfo{ vk::InstanceCreateFlags(), &appInfo, static_cast<uint32_t>(layers.size()), layers.data(),
			static_cast<uint32_t>(glfwExtensionsVector.size()), glfwExtensionsVector.data() }); // Starting to become a fan of unique pointers ;D

		if (m_Spec.Debug)
		{
			m_DLDI = vk::DispatchLoaderDynamic(*m_Instance, vkGetInstanceProcAddr);
			m_DebugMessenger = m_Instance->createDebugUtilsMessengerEXTUnique(
				vk::DebugUtilsMessengerCreateInfoEXT{ {}, vk::DebugUtilsMessageSeverityFlagBitsEXT::eError | vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |
						vk::DebugUtilsMessageSeverityFlagBitsEXT::eVerbose /* | vk::DebugUtilsMessageSeverityFlagBitsEXT::eInfo */, // Info is annoying
					vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral | vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |
				vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance, debugCallback }, nullptr, m_DLDI);
		}

		VkSurfaceKHR surfaceTmp; // Is there a better way to do this? I'm trying to avoid C style casts, i'm using vulkan.*HPP* for a reason
		glfwCreateWindowSurface(*m_Instance, m_Window, nullptr, &surfaceTmp);
		m_Surface = vk::UniqueSurfaceKHR(surfaceTmp, *m_Instance);

		std::vector<vk::PhysicalDevice> physicalDevices = m_Instance->enumeratePhysicalDevices();
		log("Devices available: "); for (auto& d : physicalDevices) log(" - "<< d.getProperties().deviceName);
		m_PhysicalDevice = physicalDevices[0]; // Need to fix later, maybe a function to choose the best device via benchmarking?
		log("Chose device: " << m_PhysicalDevice.getProperties().deviceName);

		std::vector<vk::QueueFamilyProperties> queueFamilyProperties = m_PhysicalDevice.getQueueFamilyProperties();

		size_t graphicsQueueFamilyIndex = std::distance(queueFamilyProperties.begin(), std::find_if(queueFamilyProperties.begin(), queueFamilyProperties.end(),
			[](vk::QueueFamilyProperties const& qfp) { return qfp.queueFlags & vk::QueueFlagBits::eGraphics; }));

		size_t presentQueueFamilyIndex = 0u;
		for (uint32_t i = 0; i < queueFamilyProperties.size(); i++)
			if (m_PhysicalDevice.getSurfaceSupportKHR(static_cast<uint32_t>(i), m_Surface.get()))
				presentQueueFamilyIndex = i;
		log("Graphics queue family index: " << graphicsQueueFamilyIndex << "\n" << "Present queue family index: " << presentQueueFamilyIndex);

		std::set<uint32_t> uniqueQueueFamilyIndices = { static_cast<uint32_t>(graphicsQueueFamilyIndex), static_cast<uint32_t>(presentQueueFamilyIndex) };
		std::vector<uint32_t> FamilyIndices = { uniqueQueueFamilyIndices.begin(), uniqueQueueFamilyIndices.end() };

		std::vector<vk::DeviceQueueCreateInfo> queueCreateInfos;
		float queuePriority = 0.0f;
		for (auto& queueFamilyIndex : uniqueQueueFamilyIndices)
			queueCreateInfos.push_back(vk::DeviceQueueCreateInfo{ vk::DeviceQueueCreateFlags(), static_cast<uint32_t>(queueFamilyIndex), 1, &queuePriority });
		
		const std::vector<const char*> deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; // 3 seperate extension lists :/

		log("Device extensions available: "); for (auto& e : m_PhysicalDevice.enumerateDeviceExtensionProperties()) log(" - " << e.extensionName);
		log("Device extensions used: "); for (auto& e : deviceExtensions) log(" - " << e);

		m_Device = m_PhysicalDevice.createDeviceUnique(vk::DeviceCreateInfo( vk::DeviceCreateFlags(), static_cast<uint32_t>(queueCreateInfos.size()),
			queueCreateInfos.data(), 0u, nullptr, static_cast<uint32_t>(deviceExtensions.size()), deviceExtensions.data()));

		uint32_t imageCount = 2;
		struct SM { // Black magic, from dokipen3d on github
			vk::SharingMode sharingMode;
			uint32_t familyIndicesCount;
			uint32_t* familyIndicesDataPtr;
		} sharingModeUtil{ (graphicsQueueFamilyIndex != presentQueueFamilyIndex) ?
							   SM{ vk::SharingMode::eConcurrent, 2u, FamilyIndices.data() } :
							   SM{ vk::SharingMode::eExclusive, 0u, static_cast<uint32_t*>(nullptr) } };

		vk::Format format = vk::Format::eB8G8R8A8Unorm;
		vk::Extent2D extent{ m_Spec.Width, m_Spec.Height };

		m_Swapchain = m_Device->createSwapchainKHRUnique(vk::SwapchainCreateInfoKHR{ {}, m_Surface.get(), imageCount, format,vk::ColorSpaceKHR::eSrgbNonlinear,
			extent, 1, vk::ImageUsageFlagBits::eColorAttachment, sharingModeUtil.sharingMode, sharingModeUtil.familyIndicesCount, sharingModeUtil.familyIndicesDataPtr,
			vk::SurfaceTransformFlagBitsKHR::eIdentity, vk::CompositeAlphaFlagBitsKHR::eOpaque, vk::PresentModeKHR::eFifo, true, nullptr });
		m_SwapChainImages = m_Device->getSwapchainImagesKHR(m_Swapchain.get());

		m_ImageViews.reserve(m_SwapChainImages.size());
		for (vk::Image image : m_SwapChainImages)
		{
			vk::ImageViewCreateInfo imageViewCreateInfo(vk::ImageViewCreateFlags(), image, vk::ImageViewType::e2D, format,
				vk::ComponentMapping{ vk::ComponentSwizzle::eR, vk::ComponentSwizzle::eG, vk::ComponentSwizzle::eB, vk::ComponentSwizzle::eA },
				vk::ImageSubresourceRange{ vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1 });
			m_ImageViews.push_back(m_Device->createImageViewUnique(imageViewCreateInfo));
		}
		
		std::vector<char> vertShaderCode = readFile(m_Spec.VertexShader);
		vk::ShaderModuleCreateInfo vertShaderCreateInfo = vk::ShaderModuleCreateInfo{ {}, vertShaderCode.size(),
			reinterpret_cast<const uint32_t*>(vertShaderCode.data()) };
		vk::UniqueShaderModule vertexShaderModule = m_Device->createShaderModuleUnique(vertShaderCreateInfo);

		std::vector<char> fragShaderCode = readFile(m_Spec.FragmentShader);
		vk::ShaderModuleCreateInfo fragShaderCreateInfo = vk::ShaderModuleCreateInfo{ {}, fragShaderCode.size(),
			reinterpret_cast<const uint32_t*>(fragShaderCode.data()) };
		vk::UniqueShaderModule fragmentShaderModule = m_Device->createShaderModuleUnique(fragShaderCreateInfo);

		vk::PipelineShaderStageCreateInfo vertShaderStageInfo{ {},
			vk::ShaderStageFlagBits::eVertex, *vertexShaderModule, "main" }; // How does multiple vertex and fragment shaders work? Like in Unity for example

		vk::PipelineShaderStageCreateInfo fragShaderStageInfo{ {},
			vk::ShaderStageFlagBits::eFragment, *fragmentShaderModule, "main" };

		std::vector<vk::PipelineShaderStageCreateInfo> pipelineShaderStages{ vertShaderStageInfo, fragShaderStageInfo };

		vk::PipelineVertexInputStateCreateInfo vertexInputInfo{ {}, 0u, nullptr, 0u, nullptr };

		vk::PipelineInputAssemblyStateCreateInfo inputAssembly{ {}, vk::PrimitiveTopology::eTriangleList, false };

		vk::Viewport viewport{ 0.0f, 0.0f, static_cast<float>(m_Spec.Width), static_cast<float>(m_Spec.Height), 0.0f, 1.0f };
		vk::Rect2D scissor{ { 0, 0 }, extent };
		vk::PipelineViewportStateCreateInfo viewportState{ {}, 1, &viewport, 1, &scissor };

		// Could turn this into another type of spec file, like a render spec or something
		// I wish it was the same with extensions, but you need to chain them together via create infos, hope i'm wrong though
		vk::PipelineRasterizationStateCreateInfo rasterizer{ {}, /*depthClamp*/ false, /*rasterizeDiscard*/ false, vk::PolygonMode::eFill, {},
			/*frontFace*/ vk::FrontFace::eCounterClockwise, {}, {}, {}, {}, 1.0f };
		vk::PipelineMultisampleStateCreateInfo multisampling{ {}, vk::SampleCountFlagBits::e1, false, 1.0 };
		vk::PipelineColorBlendAttachmentState colorBlendAttachment{ {}, /*srcCol*/ vk::BlendFactor::eOne, /*dstCol*/ vk::BlendFactor::eZero,
			/*colBlend*/ vk::BlendOp::eAdd, /*srcAlpha*/ vk::BlendFactor::eOne, /*dstAlpha*/ vk::BlendFactor::eZero, /*alphaBlend*/ vk::BlendOp::eAdd,
			vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG | vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA };
		vk::PipelineColorBlendStateCreateInfo colorBlending{ {}, /*logicOpEnable=*/false,
			vk::LogicOp::eCopy, /*attachmentCount=*/1, /*colourAttachments=*/&colorBlendAttachment };

		m_PipelineLayout = m_Device->createPipelineLayoutUnique({}, nullptr);

		vk::AttachmentDescription colorAttachment{ {}, format, vk::SampleCountFlagBits::e1, vk::AttachmentLoadOp::eClear, vk::AttachmentStoreOp::eStore,
			{}, {}, {}, vk::ImageLayout::ePresentSrcKHR };
		vk::AttachmentReference colourAttachmentRef{ 0, vk::ImageLayout::eColorAttachmentOptimal };

		vk::SubpassDescription subpass{ {}, vk::PipelineBindPoint::eGraphics, /*inAttachmentCount*/ 0, nullptr, 1, &colourAttachmentRef };

		vk::FenceCreateInfo fenceCreateInfo{ vk::FenceCreateFlagBits::eSignaled }; // CPU synchronisation
		m_InFlightFence = m_Device->createFenceUnique(fenceCreateInfo);

		vk::SemaphoreCreateInfo semaphoreCreateInfo{}; // GPU order of commands?
		m_ImageAvailableSemaphore = m_Device->createSemaphoreUnique(semaphoreCreateInfo);
		m_RenderFinishedSemaphore = m_Device->createSemaphoreUnique(semaphoreCreateInfo);

		vk::SubpassDependency subpassDependency{ VK_SUBPASS_EXTERNAL, 0, vk::PipelineStageFlagBits::eColorAttachmentOutput,
			vk::PipelineStageFlagBits::eColorAttachmentOutput, {}, vk::AccessFlagBits::eColorAttachmentRead | vk::AccessFlagBits::eColorAttachmentWrite };

		m_RenderPass = m_Device->createRenderPassUnique(vk::RenderPassCreateInfo{ {}, 1, &colorAttachment, 1, &subpass, 1, &subpassDependency });

		vk::GraphicsPipelineCreateInfo pipelineCreateInfo{ {}, 2, pipelineShaderStages.data(),&vertexInputInfo, &inputAssembly, nullptr, &viewportState,
			&rasterizer, &multisampling, nullptr, &colorBlending, nullptr, *m_PipelineLayout, *m_RenderPass, 0 };

		m_Pipeline = m_Device->createGraphicsPipelineUnique({}, pipelineCreateInfo).value;

		m_Framebuffers = std::vector<vk::UniqueFramebuffer>(imageCount);
		for (size_t i = 0; i < m_ImageViews.size(); i++)
			m_Framebuffers[i] = m_Device->createFramebufferUnique(vk::FramebufferCreateInfo{ {}, *m_RenderPass, 1, &(*m_ImageViews[i]), extent.width, extent.height, 1 });
		
		m_CommandPoolUnique = m_Device->createCommandPoolUnique({ {}, static_cast<uint32_t>(graphicsQueueFamilyIndex) });

		m_CommandBuffers = m_Device->allocateCommandBuffersUnique(vk::CommandBufferAllocateInfo(m_CommandPoolUnique.get(), vk::CommandBufferLevel::ePrimary,
			static_cast<uint32_t>(m_Framebuffers.size())));

		m_DeviceQueue = m_Device->getQueue(static_cast<uint32_t>(graphicsQueueFamilyIndex), 0);
		m_PresentQueue = m_Device->getQueue(static_cast<uint32_t>(presentQueueFamilyIndex), 0);

		for (size_t i = 0; i < m_CommandBuffers.size(); i++)
		{
			auto beginInfo = vk::CommandBufferBeginInfo{};
			m_CommandBuffers[i]->begin(beginInfo);
			vk::ClearValue clearValues{};
			vk::RenderPassBeginInfo renderPassBeginInfo{ m_RenderPass.get(), m_Framebuffers[i].get(), vk::Rect2D{ { 0, 0 }, extent }, 1, &clearValues };
			// It's like a C# builder but worse :cringe:
			m_CommandBuffers[i]->beginRenderPass(renderPassBeginInfo, vk::SubpassContents::eInline);
			m_CommandBuffers[i]->bindPipeline(vk::PipelineBindPoint::eGraphics, *m_Pipeline);
			m_CommandBuffers[i]->draw(3, 1, 0, 0);
			m_CommandBuffers[i]->endRenderPass();
			m_CommandBuffers[i]->end();
		}
	}

	void Application::Run()
	{
		while (!glfwWindowShouldClose(m_Window))
		{
			glfwPollEvents();

			m_Device->waitForFences(1, &m_InFlightFence.get(), VK_TRUE, UINT64_MAX);
			m_Device->resetFences(1, &m_InFlightFence.get());

			vk::ResultValue<uint32_t> imageIndex = m_Device->acquireNextImageKHR(m_Swapchain.get(), std::numeric_limits<uint64_t>::max(),
				m_ImageAvailableSemaphore.get(), {});

			vk::PipelineStageFlags waitStageMask = vk::PipelineStageFlagBits::eColorAttachmentOutput;

			vk::SubmitInfo submitInfo{ 1, &m_ImageAvailableSemaphore.get(), &waitStageMask, 1, &m_CommandBuffers[imageIndex.value].get(), 1,
				&m_RenderFinishedSemaphore.get() };

			m_DeviceQueue.submit(submitInfo, m_InFlightFence.get());

			vk::PresentInfoKHR presentInfo{ 1, &m_RenderFinishedSemaphore.get(), 1, &m_Swapchain.get(), &imageIndex.value };
			m_PresentQueue.presentKHR(presentInfo);
		}
	}

	Application::~Application()
	{
		m_Device->waitIdle(); // Removing this adds 2 errors, but everything is in unique pointers so less destructors :)
		glfwDestroyWindow(m_Window);
		glfwTerminate();
	}
}